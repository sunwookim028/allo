#!/usr/bin/env python3
"""
Demonstration of Stateful type → MLIR → Vitis HLS translation.
Shows how Stateful variables (with _stateful_ naming pattern) are translated 
to static variables in HLS C++ code.
"""

import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from allo.backend.hls import HLSModule
import re

print("=" * 80)
print("STATEFUL TYPE → MLIR → VITIS HLS DEMONSTRATION")
print("=" * 80)

# Step 1: Show Allo code with Stateful type
print("\n" + "=" * 80)
print("STEP 1: Allo kernel with Stateful variable")
print("=" * 80)

print("""
In Allo, you would write:

def accumulator(x: int32) -> int32:
    state: Stateful[int32] = 0  # Stateful variable declaration
    current = state
    new_state = current + x
    state = new_state
    return state

This creates a stateful variable that persists across kernel invocations.
""")

# Step 2: Show the MLIR representation
print("\n" + "=" * 80)
print("STEP 2: MLIR representation (generated by Allo)")
print("=" * 80)

# MLIR with stateful variable (naming pattern: *_stateful_*)
mlir_content = """module {
  memref.global "private" @state_stateful_123456789 : memref<i32> = dense<0>
  func.func @accumulator(%arg0: i32) -> i32 attributes {itypes = "s", otypes = "s"} {
    %0 = memref.get_global @state_stateful_123456789 : memref<i32>
    %1 = memref.load %0[] : memref<i32>
    %2 = arith.addi %1, %arg0 : i32
    memref.store %2, %0[] : memref<i32>
    %3 = memref.load %0[] : memref<i32>
    return %3 : i32
  }
}"""

print("\nGenerated MLIR:")
print("-" * 80)
print(mlir_content)

# Extract stateful variable name
stateful_pattern = r'@(\w+_stateful_\d+)'
matches = re.findall(stateful_pattern, mlir_content)
if matches:
    stateful_var_name = matches[0]
    print(f"\n✓ Found stateful variable: @{stateful_var_name}")
    print(f"  Pattern: *_stateful_* (recognized by translation pass)")

# Step 3: Translate to Vitis HLS
print("\n" + "=" * 80)
print("STEP 3: Translate MLIR to Vitis HLS C++")
print("=" * 80)

try:
    hls_mod = HLSModule(
        mod=mlir_content,
        top_func_name="accumulator",
        platform="vitis_hls",
        func_args=[('arg0', 'i32')],
    )
    hls_code = hls_mod.hls_code
    
    print("\nGenerated Vitis HLS C++ code:")
    print("-" * 80)
    print(hls_code)
    
    # Verify static variable was generated
    if matches:
        var_name = matches[0]
        if f"static int32_t {var_name}" in hls_code:
            print(f"\n✓ SUCCESS: Stateful variable '{var_name}' correctly emitted as STATIC!")
            print(f"  The variable will persist across kernel invocations.")
        elif f"int32_t {var_name}" in hls_code:
            print(f"\n✗ FAILED: Stateful variable '{var_name}' emitted as global (not static)")
        else:
            print(f"\n? Variable '{var_name}' not found in HLS output")
    
    # Save output
    output_file = Path(__file__).parent / "stateful_demo_output.cpp"
    with open(output_file, "w") as f:
        f.write(hls_code)
    print(f"\n✓ Output saved to: {output_file}")
    
except Exception as e:
    print(f"\n✗ Translation failed: {e}")
    import traceback
    traceback.print_exc()

print("\n" + "=" * 80)
print("DEMONSTRATION COMPLETE")
print("=" * 80)
print("""
Summary:
1. Allo Stateful[int32] type creates memref.global with naming pattern: *_stateful_*
2. MLIR translation pass (EmitVivadoHLS.cpp) recognizes _stateful_ pattern
3. Static variable emitted in C++ code: static int32_t state_stateful_123456789 = {0};
4. Static variable persists across kernel invocations (correct behavior for stateful variables)

Key Implementation:
- Translation code checks: if (symName.find("_stateful_") != std::string::npos)
- Emits: "static " keyword before variable declaration
- This allows stateful variables to maintain state between kernel calls
""")
