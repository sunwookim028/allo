# miniTPU_HLS

Mini TPU-style control program for a Vitis HLS single-BRAM accelerator. The
design emulates a minimal instruction stream that drives shared operations on
on-chip memory: host-to-BRAM DMA, 2×2 matrix multiply, vector add, scaling, and
BRAM-to-host DMA.

## Directory Layout
- `include/`: shared headers for BRAM layout, opcodes, and command helpers.
- `src/`: HLS kernel entry point (`top_module.cpp`) and helpers.
- `host/`: C++ testbench driving the kernel in C-simulation.
- `scripts/`: environment setup and Vitis HLS automation.
- `build/`: generated by the Makefile for build artifacts.

## BRAM & Instruction Model
- Shared BRAM: 256 words (32-bit each), inferred as a single-port block RAM.
- Address map (word offsets):
  - `BRAM_ADDR_A` – operand matrix `A`
  - `BRAM_ADDR_B` – operand matrix `B`
  - `BRAM_ADDR_S` – scalar `s`
  - `BRAM_ADDR_C` – intermediate result `C = A×B`
  - `BRAM_ADDR_D` – intermediate result `D = C + A`
  - `BRAM_ADDR_E` – final result `E = s·D`
- Instructions use the `mini_tpu::Command` struct:

```
opcode | addr0 | addr1 | addr2 | length | scalar
------------------------------------------------
LOAD   | host  | bram  |   -   | words  |   -
STORE  | bram  | host  |   -   | words  |   -
MATMUL |   A   |   B   |   C   |   -    |   -
VECADD |   A   |   B   |  out  | words  |   -
SCALE  |  in   |  out  |   -   | words  | scalar
```

## Prerequisites
- C++17 compiler (tested with `g++ 11`).
- Xilinx Vitis HLS (optional for hardware synthesis).

## Quick Start
```sh
# 1. Source the shared playground environment (configures Python, LLVM, Vitis paths)
source ../setup_env.sh

# 2. (Optional) Locate Vitis installation explicitly
make setup

# 3. Build host test binary
make build_host

# 4. Run 10 randomized trials (default)
make csim

# Custom trials and seed
make csim TRIALS=25 SEED=42
```

## Vitis HLS Workflow
```sh
make hls
```

The `scripts/run_hls.tcl` script creates a project, runs C-sim and synthesis,
and exports the RTL as an IP catalog component. Adjust the target part number,
clock period, and add a cycle-accurate RTL test bench before enabling
`cosim_design`.

## Notes
- BRAM accesses are serialized through a single port; operations run in the
  order issued by the command stream.
- Scaling and vector addition use straightforward sequential loops with II=1
  pipelining pragmas for consistent performance.
- Host test ensures hardware results match software reference for randomly
  generated operands to guard functional coverage.


